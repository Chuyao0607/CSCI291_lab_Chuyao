#include <webots/robot.h>
#include <webots/light_sensor.h>
#include <webots/distance_sensor.h>
#include <webots/motor.h>
#include <stdio.h>
#include <math.h>

#define TIME_STEP 32
#define MAX_SPEED 6.28
#define TOLERANCE 0.05

// Sensor and motor tags
WbDeviceTag left_motor, right_motor;
WbDeviceTag ps[8];  // 8 个接近传感器

bool first_move = true;

// 初始化设备
void initialize_devices() {
  left_motor = wb_robot_get_device("left wheel motor");
  right_motor = wb_robot_get_device("right wheel motor");
  if (left_motor == NULL || right_motor == NULL) {
    printf("Error: Motors not found!\n");
    return;
  }

  wb_motor_set_position(left_motor, INFINITY);
  wb_motor_set_position(right_motor, INFINITY);

  // 初始化接近传感器
  for (int i = 0; i < 8; i++) {
    char sensor_name[4];
    sprintf(sensor_name, "ps%d", i);
    ps[i] = wb_robot_get_device(sensor_name);
    wb_distance_sensor_enable(ps[i], TIME_STEP);
  }
}

// 处理传感器数据并控制机器人
void process_sensors_and_control() {
  // 初次移动，机器人直行
  if (first_move) {
    wb_motor_set_velocity(left_motor, 0.5 * MAX_SPEED);
    wb_motor_set_velocity(right_motor, 0.5 * MAX_SPEED);
    first_move = false;
    return;
  }

  // 获取接近传感器值
  double ps_values[8];
  for (int i = 0; i < 8; i++) {
    ps_values[i] = wb_distance_sensor_get_value(ps[i]);
  }

  // 定义方向障碍物标志
  bool right_front_obstacle = ps_values[0] > 80.0;
  bool corner_right = ps_values[1] > 80.0;
  bool side_right = ps_values[2] > 80.0;
  bool rear_right = ps_values[3] > 80.0;
  bool rear_left = ps_values[4] > 80.0;
  bool side_left = ps_values[5] > 80.0;
  bool corner_left = ps_values[6] > 80.0;
  bool left_front_obstacle = ps_values[7] > 80.0;

  bool front_obstacle = right_front_obstacle || left_front_obstacle;

  double left_speed = MAX_SPEED;
  double right_speed = MAX_SPEED;

  if (front_obstacle) {
  if (side_left && side_right) {
    // 前方和两侧均有障碍物，后退
    left_speed = -0.5 * MAX_SPEED;
    right_speed = -0.5 * MAX_SPEED;
  } else if (side_left) {
    // 前方和左侧有障碍物，右转
    left_speed = MAX_SPEED;
    right_speed = 0.1 * MAX_SPEED;
  } else if (side_right) {
    // 前方和右侧有障碍物，左转
    left_speed = 0.1 * MAX_SPEED;
    right_speed = MAX_SPEED;
  } else {
    // 前方有障碍物但两侧清空，右转为默认行为
    left_speed = MAX_SPEED;
    right_speed = -0.1 * MAX_SPEED;
  }
} else if (!front_obstacle) {
  if (side_left && !side_right) {
    // 如果左侧清空而右侧有障碍物，优先向左转，遵循左手法则
    left_speed = 0.1 * MAX_SPEED;
    right_speed = MAX_SPEED;
  } else if (!side_left && !side_right) {
    // 无前方障碍物且左右两侧都清空，直行
    left_speed = 0.5 * MAX_SPEED;
    right_speed = 0.5 * MAX_SPEED;
  } else if (!side_left && side_right) {
    // 如果右侧清空，左侧有障碍物，优先左转
    left_speed = 0.1 * MAX_SPEED;
    right_speed = MAX_SPEED;
  }
} else {
  // 处理其他情况，例如后方障碍
  left_speed = MAX_SPEED;
  right_speed = MAX_SPEED;
}



  // 设置电机速度
  wb_motor_set_velocity(left_motor, left_speed);
  wb_motor_set_velocity(right_motor, right_speed);
}

int main() {
  wb_robot_init();

  initialize_devices();

  while (wb_robot_step(TIME_STEP) != -1) {
    process_sensors_and_control();
  }

  wb_robot_cleanup();
  return 0;
}
