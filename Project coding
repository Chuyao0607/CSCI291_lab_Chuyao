#include <webots/robot.h>
#include <webots/light_sensor.h>
#include <webots/distance_sensor.h>
#include <webots/motor.h>
#include <stdio.h>

#define TIME_STEP 32 // Time step in milliseconds
#define MAX_SPEED 0.5 * 6.28

// Sensor and motor tags
WbDeviceTag light_sensor, distance_sensor, left_motor, right_motor;
WbDeviceTag ps[8];  // Store 8 proximity sensors

// Flag to track the first movement
bool first_move = true;

// Initialize sensors and motors
void initialize_devices() {
  // Initialize motors first to avoid invalid device tag error
  left_motor = wb_robot_get_device("left wheel motor");
  right_motor = wb_robot_get_device("right wheel motor");

  // Check if motor devices are correctly retrieved
  if (left_motor == NULL || right_motor == NULL) {
    printf("Error: Motor devices not found.\n");
    return;
  }

  // Set motor positions to infinity for velocity control
  wb_motor_set_position(left_motor, INFINITY);
  wb_motor_set_position(right_motor, INFINITY);

  // Initialize light sensor
  light_sensor = wb_robot_get_device("lts");
  wb_light_sensor_enable(light_sensor, TIME_STEP);

  // Initialize distance sensor
  distance_sensor = wb_robot_get_device("Dts");
  wb_distance_sensor_enable(distance_sensor, TIME_STEP);

  // Initialize proximity sensors
  for (int i = 0; i < 8; i++) {
    char sensor_name[4];
    sprintf(sensor_name, "ps%d", i);
    ps[i] = wb_robot_get_device(sensor_name);
    wb_distance_sensor_enable(ps[i], TIME_STEP);
  }
}

// Process sensor data and control the motors
void process_sensors_and_control() {
  // If this is the first move, make the robot go straight
  if (first_move) {
    wb_motor_set_velocity(left_motor, 0.5 * MAX_SPEED);
    wb_motor_set_velocity(right_motor, 0.5 * MAX_SPEED);
    first_move = false;
    return;
  }

  // Read proximity sensors
  double ps_values[8];
  for (int i = 0; i < 8; i++) {
    ps_values[i] = wb_distance_sensor_get_value(ps[i]);
  }

  // Print sensor values for debugging
  printf("Sensor values: ");
  for (int i = 0; i < 8; i++) {
    printf("%f ", ps_values[i]);
  }
  printf("\n");

  // Detect obstacles
  bool front_obstacle = ps_values[0] > 90.0;
  bool side_left = ps_values[2] > 90.0;   // 左侧
  bool corner_left = ps_values[1] > 90.0;
  bool rear_left = ps_values[3] > 90.0;
  bool back_obstacle = ps_values[4] > 90.0;
  bool side_right = ps_values[6] > 90.0;  // 右侧
  bool corner_right = ps_values[7] > 90.0; // 右前角
  bool rear_right = ps_values[5] > 90.0;   // 右后

  // Set initial motor speeds
  double left_speed = MAX_SPEED;
  double right_speed = MAX_SPEED;

  // Handle obstacle detection and movement
  if (front_obstacle) {
    // If there's an obstacle in front, check left or right
    if (!side_left && !side_right) {
      // If both sides are clear, turn away from the obstacle
      left_speed = 0.1 * MAX_SPEED;
      right_speed = MAX_SPEED; // Turn right
    } else if (side_left) {
      // If there's an obstacle on the left, turn right
      left_speed = MAX_SPEED;
      right_speed = 0.1 * MAX_SPEED;
    } else if (side_right) {
      // If there's an obstacle on the right, turn left
      left_speed = 0.1 * MAX_SPEED;
      right_speed = MAX_SPEED;
    }
  } else if (!front_obstacle && !side_left) {
    // If there's no obstacle in front and left is clear, move forward
    left_speed = 0.5 * MAX_SPEED;
    right_speed = 0.5 * MAX_SPEED;
  } else {
    // Handle other cases such as moving in case of side or rear obstacles
    left_speed = MAX_SPEED;
    right_speed = MAX_SPEED;
  }else if (front_obstacle && side_left && side_right) {
    // If there's an obstacle in front, left and right, try to move backward
    left_speed = -0.5 * MAX_SPEED;
    right_speed = -0.5 * MAX_SPEED;
}


  // Set motor speeds
  wb_motor_set_velocity(left_motor, left_speed);
  wb_motor_set_velocity(right_motor, right_speed);
}

int main() {
  wb_robot_init();

  // Initialize other devices
  initialize_devices();

  while (wb_robot_step(TIME_STEP) != -1) {
    // Process sensors and control the robot
    process_sensors_and_control();
  }

  wb_robot_cleanup();
  return 0;
}

  }

  wb_robot_cleanup();
  return 0;
}
