#include <webots/robot.h>
#include <iostream>
#include <webots/light_sensor.h>
#include <webots/distance_sensor.h>
#include <webots/motor.h>
#include <webots/light_sensor.h>
#include <stdio.h>

#define TIME_STEP 32 // Time step in milliseconds
#define MAX_SPEED 6.78
using namespace webots;
void initialize_devices();
void process_sensors_and_control();

// Sensor and motor tags
WbDeviceTag light_sensor, distance_sensor, left_motor, right_motor;
WbDeviceTag ps[8];  // Store 8 proximity sensors

// Flag to track the first movement
bool first_move = true;

// Initialize sensors and motors
void initialize_devices() {
  light_sensor = wb_robot_get_device("lts");
  wb_light_sensor_enable(light_sensor, TIME_STEP);

  distance_sensor = wb_robot_get_device("Dts");
  wb_distance_sensor_enable(distance_sensor, TIME_STEP);

  // Initialize proximity sensors
  for (int i = 0; i < 8; i++) {
    char sensor_name[4];
    sprintf(sensor_name, "ps%d", i);
    ps[i] = wb_robot_get_device(sensor_name);
    wb_distance_sensor_enable(ps[i], TIME_STEP);
  }

  // Initialize motors
  left_motor = wb_robot_get_device("left_motor");
  right_motor = wb_robot_get_device("right_motor");

  wb_motor_set_position(left_motor, INFINITY);
  wb_motor_set_position(right_motor, INFINITY);
}

// Process sensor data and control the motors
void process_sensors_and_control() {
  // If this is the first move, make the robot go straight
  if (first_move) {
    wb_motor_set_velocity(left_motor, 0.5 * MAX_SPEED);
    wb_motor_set_velocity(right_motor, 0.5 * MAX_SPEED);
    first_move = false;
    return;  
  }

  // Read proximity sensors
  double ps_values[8];
  for (int i = 0; i < 8; i++) {
    ps_values[i] = wb_distance_sensor_get_value(ps[i]);
  }

  // Print sensor values for debugging
  printf("Sensor values: ");
  for (int i = 0; i < 8; i++) {
    printf("%f ", ps_values[i]);
  }
  printf("\n");

  // Detect obstacles
  bool right_obstacle = ps_values[2] > 100.0;
  bool left_obstacle = ps_values[5] > 100.0;
  bool front_obstacle = ps_values[0] > 100.0;
  bool corner_obstacle=ps_values[6]>100.0;

  // Set initial motor speeds
  double left_speed = MAX_SPEED;
  double right_speed = MAX_SPEED;

  // Determine robot movement based on proximity sensor data
  if (front_obstacle==0 && left_obstacle==0) {
    left_speed = MAX_SPEED;
    right_speed = 0.1 * MAX_SPEED; // Move forward
  } 
   else if (front_obstacle==0 && left_obstacle==1) {
    // If there's an obstacle in front, back up and turn
    left_speed = MAX_SPEED;
    right_speed = MAX_SPEED;
   else if(front_obstacle==1 && left_obstacle==0){
    left_speed = MAX_SPEED;
    right_speed = 0.1 * MAX_SPEED; 
    }
    else if(front_obstacle==1 && left_obstacle==1){
     left_speed = 0.1* MAX_SPEED;
     right_speed = MAX_SPEED; 
    if (corner_obstacle==1){
     left_speed = 0.1* MAX_SPEED;
     right_speed = MAX_SPEED; 
    }
}
  // Set motor speeds
  wb_motor_set_velocity(left_motor, left_speed);
  wb_motor_set_velocity(right_motor, right_speed);
}

int main(int argc, char **argv) {
  Robot robot;

  // Initialize light sensor
  LightSensor *lightSensor = robot.getLightSensor("light_sensor");
  lightSensor->enable(TIME_STEP);  

  // Initialize motors
  Motor *leftMotor = robot.getMotor("left wheel");
  Motor *rightMotor = robot.getMotor("right wheel");

  leftMotor->setPosition(INFINITY);
  rightMotor->setPosition(INFINITY);

  // Initialize other devices
  initialize_devices();

  while (robot.step(TIME_STEP) != -1) {
    // Process sensors and control the robot
    double lightValue = lightSensor->getValue();
    printf("Light sensor value: %f\n", lightValue);

    if (lightValue > 500) { 
      // If light intensity is high (close to PointLight), stop the robot
      leftMotor->setVelocity(0.0);
      rightMotor->setVelocity(0.0);
    } else {
      // Otherwise, continue normal obstacle avoidance behavior
      process_sensors_and_control();
    }
  }

  wb_robot_cleanup();
  return 0;
}
